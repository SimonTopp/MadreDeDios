---
title: "AquaModel Evalution"
author: "Simon Topp"
date: "3/01/2019"
output: html_document
editor_options:
  chunk_output_type: console
---
This script generates error metrics and figures for evaluating xgBoost model performance for AquaModel.  All error metrics are for testing data not used in model training.

```{r setup, include=FALSE}
library(tidyverse)
library(feather)
library(knitr)
library(purrr)
library(reticulate)
library(googledrive)
library(sf)
library(lubridate)
library(xgboost)
library(onehot)
library(viridis)
library(kableExtra)
knitr::opts_chunk$set(error = F)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(message = F)
knitr::opts_chunk$set(echo = F)
```


```{r, eval = F}
#{python, engine.path ='/usr/local/bin/python2'}
##repl_python basically starts a python bash window within your R chunk.  This can be used to actually interact with earth engine.
repl_python()

import time
import ee
import os
#import feather
ee.Initialize()

#Source necessary functions.
execfile('GEE_pull_functions_MdD.py')

#Load in Pekel water occurance Layer and Landsat Collections.
PekelMask = False
pekel = ee.Image('JRC/GSW1_0/GlobalSurfaceWater')

l8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR')
l7 = ee.ImageCollection('LANDSAT/LE07/C01/T1_SR')
l5 = ee.ImageCollection('LANDSAT/LT05/C01/T1_SR')

#Identify collection for use in sourced functions.
collection = 'SR'

#Standardize band names between the various collections and aggregate 
#them into one image collection

bn8 = ['B2','B3', 'B4', 'B5', 'B6','B7', 'pixel_qa']
bn57 = ['B1', 'B2', 'B3', 'B4', 'B5','B7', 'pixel_qa']
bns = ['Blue', 'Green', 'Red', 'Nir', 'Swir1', 'Swir2', 'qa']
  
ls5 = l5.select(bn57, bns)
ls7 = l7.select(bn57, bns)
ls8 = l8.select(bn8, bns)

ls = ee.ImageCollection(ls5.merge(ls7).merge(ls8))\
.filter(ee.Filter.lt('CLOUD_COVER', 50))

#Select the occurence layer in the pekel mask, which is just the 
#percentage of water occurence over a given pixel from 1985-2015.
#Set the percent occurance threshold and create a watermask from the result.
threshold = 80
water = pekel.select('occurrence').gt(threshold)
water = water.updateMask(water)

lakes = ee.FeatureCollection('users/sntopp/MdD/MdD_Oxbow_ply')

# Filter lakes that have already been downloaded
lakeID = lakes.aggregate_array('Name').getInfo()
dlDir = 'C:/Users/sntopp/Google Drive/gits/MadreDeDios/OxbowPull'
filesDown = os.listdir(dlDir)
filesDown = [int(i.replace(".csv", "")) for i in filesDown]

lakeID  = [i for i in lakeID if i not in filesDown]
                        
for x in range(0,len(lakeID)):
#for x in range(0,5):
    lake = lakes.filter(ee.Filter.eq('Name', lakeID[x])).first()
    shell = ee.Feature(None)
    #FilterBounds for lake, update masks for water occurence, clouds, roads, etc.
    #Remove any images with clouds directly over the waterbody
    
    lsover = ls.filterBounds(lake.geometry())\
    #.map(clipImage)
      
    
  ## Map over sites within specific path/row and pull reflectance values
    dataMed = lsover.map(lakePull).filter(ee.Filter.eq('cScore', 0))
    #dataVar = lsover.map(lakeVar).flatten()
    dataOutm = ee.batch.Export.table.toDrive(collection = dataMed, \
                                              description = str(lakeID[x]) + '_Water',\
                                              folder = 'MdD_OxbowPull',\
                                              fileFormat = 'csv')
    # dataOutv = ee.batch.Export.table.toDrive(collection = dataVar, \
    #                                           description = str(lakeID[x]),\
    #                                           folder = 'aquaModel_MacroVar',\
    #                                           fileFormat = 'csv')
    # 
   #Check how many existing tasks are running and take a break if it's >15  
    maximum_no_of_tasks(15, 60)
  #Send next task.
    dataOutm.start()
    #dataOutv.start()
    print('done')
## End the python bash.
#exit

```



```{r download, eval = F}

files <- drive_ls('MdD_OxbowPull')

for (i in 1:length(files$name)){
        file <- files$id[i]
        path <- paste0('OxbowPull/',files$name[i])
        drive_download(file = as_id(file), path = path, overwrite = T)
}

paths <- list.files('OxbowPull', full.names = T)

pathsWater <- grep(pattern = '_Water', x = paths, value = T)

paths <- paths[!paths %in% pathsWater]

df <- paths %>% map_df(read.csv) 

df <- df %>%
  select(-.geo, -hillshade) %>%
  na.omit() %>%
  mutate(NR = nir/red,
  clouds = Cloud_Cover,
  BR = blue/red,
  ndvi = ((nir-red)/(nir+red)),
  ndwi = ((green- swir1)/(green + swir1)),
  sat = factor(sat, levels = c(5,7,8), labels = c('LT05', 'LE07', 'LC08')),
  date = as.POSIXct(ymd_hms(date)),
  month = as.numeric(month(date)),
  season = factor(ifelse(month %in% c(12,1,2), 'DJF',
                 ifelse(month %in% c(3,4,5), 'MAM',
                        ifelse(month %in% c(6,7,8), 'JJA', 'SON')))),
  year = year(date)) %>%
  rowwise() %>%
  mutate(yearsForms = gsub(Oxbow_ID, pattern = 'pre', replacement = ''),  
  yearFormed = as.numeric(tail(str_split(yearsForms, pattern = '_')[[1]],1))) %>%
  ungroup()

check <- df %>%
  filter(red < 10000) %>%
  group_by(Oxbow_ID, year, season) %>%
  summarize(red = mean(red),
            ndvi = mean(ndvi)) %>%
  arrange(Oxbow_ID, year, season) %>%
  mutate(order = row_number()) %>%
  gather(red, ndvi, key = 'Measure', value = 'Reflectance')

ggplot(check, aes(x = order, y = Reflectance, color = Measure)) +
  geom_line

scale2 <- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)

check <- df %>% select(OrderUp, Oxbow_ID, ndvi, red, date, year, yearFormed, season) %>%
  filter(red < 5000,
        yearFormed > 1984) %>%
  mutate_at(vars(ndvi:red), scale2) %>%
  gather(ndvi:red, key = 'Measure', value = 'Scaled.Reflectance')

check <- df %>% select(OrderUp, Oxbow_ID, ndvi, ndwi, date, year, yearFormed, season) %>%
  #mutate_at(vars(ndvi:red), scale2) %>%
  gather(ndvi:ndwi, key = 'Measure', value = 'value')

check %>% filter(Oxbow_ID %in% c('CO_1_2007','MD_12_pre1984', 'MD_14_2015', 'MD_03_2012')
) %>%
  ggplot(., aes(x = date, y = value, color = Measure)) + 
  geom_point(alpha = .2, size = .6) +
  geom_smooth(se = F) +
  geom_vline(aes(xintercept = yearFormed)) +
  facet_wrap(~Oxbow_ID, scales = 'free') +
  labs(title = 'Water and Vegetation Indexes During Formation/Infilling')

ggsave('figures/OxbowMorph.png')

water <- pathsWater %>% map_df(read.csv) 

water <- water %>%
  select(-.geo, -hillshade) %>%
  na.omit() %>%
  mutate(NR = nir/red,
  clouds = Cloud_Cover,
  BR = blue/red,
  ndvi = ((nir-red)/(nir+red)),
  ndwi = ((green- swir1)/(green + swir1)),
  sat = factor(sat, levels = c(5,7,8), labels = c('LT05', 'LE07', 'LC08')),
  date = as.POSIXct(ymd_hms(date)),
  month = as.numeric(month(date)),
  season = factor(ifelse(month %in% c(12,1,2), 'DJF',
                 ifelse(month %in% c(3,4,5), 'MAM',
                        ifelse(month %in% c(6,7,8), 'JJA', 'SON')))),
  year = year(date)) %>%
  rowwise() %>%
  mutate(yearsForms = gsub(Oxbow_ID, pattern = 'pre', replacement = ''),  
  yearFormed = as.numeric(tail(str_split(yearsForms, pattern = '_')[[1]],1))) %>%
  ungroup()


water %>%
  filter(year > yearFormed,
         dswe > 0) %>%
  mutate(season = factor(season, levels = c('JJA', 'SON','DJF','MAM'))) %>%
  #group_by(season, year) %>%
  #summarize(BR = mean(BR)) %>%
  ggplot(., aes(x = date, y = BR, color = season)) +
  geom_point(alpha = .2,size = 1) +
  geom_smooth(se = F, method = 'loess') +
  coord_cartesian(ylim=c(0,1.5)) +
  labs(y = 'Blue/Red', title = 'Sediment Proxy by Season')
  
ggsave('figures/sedimentBySeason.png')

ggplot(water %>% filter(red < 5000), aes(x = date, y = BR, color = OrderUp, group = Oxbow_ID)) + 
  geom_point() +
  geom_smooth(se = F) +
  coord_cartesian(ylim=c(0,1.5)) +
  facet_wrap(~season)



```

